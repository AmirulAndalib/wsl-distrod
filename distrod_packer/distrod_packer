#!/usr/bin/env python3

import argparse
import tempfile
import os
import subprocess
import shutil
from typing import Iterator, Optional, Tuple, List


def main():
    parser = argparse.ArgumentParser(
        description='A script to generate the rootfs of distrod, which is bundled in the WSL distro distribution')
    parser.add_argument(
        'workspace_path', help='The path to distrod\'s workspace directory.', type=str)
    parser.add_argument(
        'output_path', help='The path of the output rootfs image.', type=str)
    args = parser.parse_args()
    pack_rootfs(args.workspace_path, args.output_path)


def pack_rootfs(workspace_path: str, output_path: str):
    with tempfile.TemporaryDirectory() as temp_dir:
        work_dir = temp_dir + "/root"
        make_minimum_mountpoints(work_dir)
        bin_names = ["distrod", "distrod-exec"]
        for bin_name in bin_names:
            bin_path = build(bin_name, workspace_path, work_dir)
            copy_dependency_libs(bin_name, work_dir)
            ld_path = get_ld_dir_in_container(os.path.basename(
                extract_dependency_libs(work_dir + bin_path)[0]))
            modify_lib_search_path(work_dir + bin_path,
                                   ld_path, get_lib_dir_in_container())
        put_static_files(work_dir)
        set_permissions(work_dir)
        set_suid(work_dir + get_distrod_dir_in_container("distrod-exec"))
        compress_rootfs(work_dir, output_path)


def make_minimum_mountpoints(work_dir: str):
    dirs = ["/proc", "/mnt", "/run", "/sys", "/dev", "/tmp", "/etc",
            get_distrod_dir_in_container(),
            get_distrod_dir_in_container("alias"),
            get_distrod_dir_in_container("lib"),
            get_distrod_dir_in_container("ld")]
    for dir in dirs:
        os.makedirs(work_dir + dir)


def build(bin_name: str, workspace_path: str, work_dir: str) -> str:
    dir_to_back = os.getcwd()
    os.chdir(workspace_path)
    res = subprocess.run(["cargo", "build", "--release", "-p", bin_name])
    if res.returncode != 0:
        raise Exception("cargo build failed")
    shutil.copy(f"./target/release/{bin_name}",
                work_dir + get_distrod_dir_in_container(bin_name))
    os.chdir(dir_to_back)
    return get_distrod_dir_in_container(bin_name)


def copy_dependency_libs(bin_name: str, work_dir: str):
    distrod_bin = work_dir + get_distrod_dir_in_container(bin_name)
    ld, libs = extract_dependency_libs(distrod_bin)
    ld_path = work_dir + get_ld_dir_in_container(os.path.basename(ld))
    shutil.copy(ld, ld_path)
    for lib in libs:
        shutil.copy(
            lib, work_dir + get_lib_dir_in_container(os.path.basename(lib)))


def extract_dependency_libs(bin_path: str) -> Tuple[str, List[str]]:
    ldd = subprocess.run(["ldd", bin_path], capture_output=True)
    if ldd.returncode != 0:
        raise Exception(f"ldd failed.")
    ldd_output = [l.strip() for l in ldd.stdout.decode("utf-8").splitlines()]
    ld = next(filter(lambda line: "ld-linux-x86-64" in line, ldd_output))
    ld = ld.split(" ")[0]

    libs = []
    for ldd_line in filter(lambda line: "=>" in line, ldd_output):
        lib_path = ldd_line.split(" ")[2]
        libs.append(lib_path)

    return (ld, libs)


def modify_lib_search_path(bin_path: str, ld_path: str, rpath: str):
    """Patch an ELF binary by patchelf"""
    patch_args = ["patchelf", "--set-interpreter", ld_path, bin_path]
    ret = subprocess.run(patch_args)
    if ret.returncode != 0:
        raise Exception(f"command failed. {patch_args}")
    patch_args = ["patchelf", "--set-rpath", rpath, bin_path]
    ret = subprocess.run(patch_args)
    if ret.returncode != 0:
        raise Exception(f"command failed. {patch_args}")


def set_permissions(work_dir: str):
    dir_to_back = os.getcwd()
    os.chdir(work_dir)
    os.system("sudo chmod 755 .")
    os.system("sudo chown -R root:root .")
    os.chdir(dir_to_back)


def set_suid(bin_path: str):
    os.system(f"sudo chmod u+s {bin_path}")
    os.system(f"sudo chmod g+s {bin_path}")
    os.system(f"ls -l {bin_path}")


def put_static_files(work_dir: str):
    shutil.copy(get_resources_dir("distrod.toml"),
                work_dir + get_distrod_dir_in_container())
    os.system(
        f"sudo chown root:root {work_dir + get_distrod_dir_in_container('distrod.toml')}")


def compress_rootfs(work_dir: str, output_path: str):
    dir_to_back = os.getcwd()
    os.chdir(work_dir)
    os.system("sudo tar czf distrod_root.tar.gz *")
    # Let the directory able to be deleted
    os.system("sudo chown -R $(whoami):$(whoami) .")
    os.chdir(dir_to_back)
    shutil.copy(work_dir + "/distrod_root.tar.gz", output_path)


def get_resources_dir(inner_path: Optional[str] = None) -> str:
    path = os.path.dirname(__file__) + "/resources"
    print(f"resource: {path}")
    if inner_path:
        path = f"{path}/{inner_path}"
    return path


def get_lib_dir_in_container(inner_path: Optional[str] = None) -> str:
    path = "lib"
    if inner_path:
        path = f"{path}/{inner_path}"
    return get_distrod_dir_in_container(path)


def get_ld_dir_in_container(inner_path: Optional[str] = None) -> str:
    path = "ld"
    if inner_path:
        path = f"{path}/{inner_path}"
    return get_distrod_dir_in_container(path)


def get_distrod_dir_in_container(inner_path: Optional[str] = None) -> str:
    path = "/opt/distrod"
    if inner_path:
        path = f"{path}/{inner_path}"
    return path


if __name__ == '__main__':
    main()
