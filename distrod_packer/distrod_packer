#!/usr/bin/env python3

import argparse
import tempfile
import os
import subprocess
import shutil
from typing import Iterator, Optional, Tuple, List


def main():
    parser = argparse.ArgumentParser(
        description='A script to generate the rootfs of distrod, which is bundled in the WSL distro distribution')
    parser.add_argument(
        'workspace_path', help='The path to distrod\'s workspace directory.', type=str)
    parser.add_argument(
        'output_path', help='The path of the output rootfs image.', type=str)
    parser.add_argument(
        '--make_distrod_release', '-r', help='Pack the release of in-distro distrod command instead of the rootfs.', action='store_true')
    args = parser.parse_args()
    if args.make_distrod_release:
        pack_distrod_release(args.workspace_path,
                             os.path.abspath(args.output_path))
    else:
        pack_rootfs(args.workspace_path, os.path.abspath(args.output_path))


def pack_rootfs(workspace_path: str, output_path: str):
    if not output_path.startswith("/"):
        raise Exception("output path should be an absolute path")
    with tempfile.TemporaryDirectory() as temp_dir:
        work_dir = temp_dir + "/root"
        make_rootfs(workspace_path, work_dir)
        compress_entire_tree(work_dir, output_path)
        make_dir_deletable(work_dir)


def pack_distrod_release(workspace_path: str, output_path: str):
    if not output_path.startswith("/"):
        raise Exception("output path should be an absolute path")
    with tempfile.TemporaryDirectory() as temp_dir:
        work_dir = temp_dir + "/root"
        make_distrod_distribution(workspace_path, work_dir)
        compress_entire_tree(
            work_dir + get_distrod_dir_in_container(), output_path)
        make_dir_deletable(work_dir)


def make_rootfs(workspace_path: str, output_dst: str):
    make_minimum_mountpoints(output_dst)
    make_distrod_distribution(workspace_path, output_dst)


def make_distrod_distribution(workspace_path: str, output_dst: str):
    work_dir = output_dst
    make_distrod_distribution_dirs(work_dir)
    bin_names = ["distrod", "distrod-exec", "portproxy"]
    for bin_name in bin_names:
        make_distrod_project_static_linux(workspace_path, work_dir, bin_name)
    make_distrod_project_static_windows(workspace_path, work_dir, "portproxy")
    copy_distrod_distribution_resources(work_dir)
    set_permissions(work_dir)
    set_suid(work_dir + get_distrod_dir_in_container("distrod-exec"))


def make_distrod_project_static_linux(workspace_path, work_dir, bin_name):
    bin_path = copy_target_binary(bin_name, workspace_path, work_dir)
    copy_dependency_libs(bin_name, work_dir)
    ld_path = get_ld_dir_in_container(os.path.basename(
        extract_dependency_libs(work_dir + bin_path)[0]))
    modify_lib_search_path(work_dir + bin_path,
                           ld_path, get_lib_dir_in_container())


def make_distrod_project_static_windows(workspace_path, work_dir, bin_name):
    binpath = copy_target_binary(bin_name + ".exe", workspace_path, work_dir)
    os.system(f"chmod a+x {work_dir + binpath}")


def copy_target_binary(bin_name: str, workspace_path: str, work_dir: str) -> str:
    shutil.copy(f"{workspace_path}/target/release/{bin_name}",
                work_dir + get_distrod_dir_in_container(bin_name))
    return get_distrod_dir_in_container(bin_name)


def copy_dependency_libs(bin_name: str, work_dir: str):
    distrod_bin = work_dir + get_distrod_dir_in_container(bin_name)
    ld, libs = extract_dependency_libs(distrod_bin)
    ld_path = work_dir + get_ld_dir_in_container(os.path.basename(ld))
    shutil.copy(ld, ld_path)
    for lib in libs:
        shutil.copy(
            lib, work_dir + get_lib_dir_in_container(os.path.basename(lib)))


def extract_dependency_libs(bin_path: str) -> Tuple[str, List[str]]:
    ldd = subprocess.run(["ldd", bin_path], capture_output=True)
    if ldd.returncode != 0:
        raise Exception(f"ldd failed.")
    ldd_output = [l.strip() for l in ldd.stdout.decode("utf-8").splitlines()]
    ld = next(filter(lambda line: "ld-linux-x86-64" in line, ldd_output))
    ld = ld.split(" ")[0]

    libs = []
    for ldd_line in filter(lambda line: "=>" in line, ldd_output):
        lib_path = ldd_line.split(" ")[2]
        libs.append(lib_path)

    return (ld, libs)


def modify_lib_search_path(bin_path: str, ld_path: str, rpath: str):
    """Patch an ELF binary by patchelf"""
    patch_args = ["patchelf", "--set-interpreter", ld_path, bin_path]
    ret = subprocess.run(patch_args)
    if ret.returncode != 0:
        raise Exception(f"command failed. {patch_args}")
    patch_args = ["patchelf", "--set-rpath", rpath, bin_path]
    ret = subprocess.run(patch_args)
    if ret.returncode != 0:
        raise Exception(f"command failed. {patch_args}")


def make_minimum_mountpoints(work_dir: str):
    dirs = ["/proc", "/mnt", "/run", "/sys", "/dev", "/tmp", "/etc", "/conf"]
    for dir in dirs:
        os.makedirs(work_dir + dir)


def make_distrod_distribution_dirs(work_dir: str):
    dirs = [
        get_distrod_dir_in_container(),
        get_distrod_dir_in_container("alias"),
        get_distrod_dir_in_container("lib"),
        get_distrod_dir_in_container("ld")]
    for dir in dirs:
        os.makedirs(work_dir + dir)


def set_permissions(work_dir: str):
    dir_to_back = os.getcwd()
    os.chdir(work_dir)
    os.system("sudo chmod 755 .")
    os.system("sudo chown -R root:root .")
    os.chdir(dir_to_back)


def set_suid(bin_path: str):
    os.system(f"sudo chmod u+s {bin_path}")
    os.system(f"sudo chmod g+s {bin_path}")


def copy_distrod_distribution_resources(work_dir: str):
    shutil.copytree(get_resources_dir(), work_dir +
                    get_distrod_dir_in_container(), dirs_exist_ok=True)


def compress_entire_tree(tree: str, output_path: str):
    dir_to_back = os.getcwd()
    os.chdir(tree)
    os.system("sudo tar czf compressed.tar.gz *")
    shutil.copy(tree + "/compressed.tar.gz", output_path)
    os.chdir(dir_to_back)


def make_dir_deletable(tree: str):
    dir_to_back = os.getcwd()
    os.chdir(tree)
    # Let the directory able to be deleted
    os.system("sudo chown -R $(whoami):$(whoami) .")
    os.chdir(dir_to_back)


def get_resources_dir(inner_path: Optional[str] = None) -> str:
    path = os.path.dirname(__file__) + "/resources"
    if inner_path:
        path = f"{path}/{inner_path}"
    return path


def get_lib_dir_in_container(inner_path: Optional[str] = None) -> str:
    path = "lib"
    if inner_path:
        path = f"{path}/{inner_path}"
    return get_distrod_dir_in_container(path)


def get_ld_dir_in_container(inner_path: Optional[str] = None) -> str:
    path = "ld"
    if inner_path:
        path = f"{path}/{inner_path}"
    return get_distrod_dir_in_container(path)


def get_distrod_dir_in_container(inner_path: Optional[str] = None) -> str:
    path = "/opt/distrod"
    if inner_path:
        path = f"{path}/{inner_path}"
    return path


if __name__ == '__main__':
    main()
